"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/config.ts
var config_exports = {};
__export(config_exports, {
  applyDecorators: () => decorateStory,
  argTypesEnhancers: () => argTypesEnhancers,
  decorators: () => decorators,
  parameters: () => parameters2,
  render: () => render,
  renderToCanvas: () => renderToCanvas
});
module.exports = __toCommonJS(config_exports);

// src/docs/config.ts
var import_docs_tools3 = require("@storybook/docs-tools");

// src/docs/extractArgTypes.ts
var import_docs_tools = require("@storybook/docs-tools");
var ARG_TYPE_SECTIONS = ["props", "events", "slots", "exposed"];
var extractArgTypes = (component) => {
  console.log("########     --- component", component);
  console.log("########     --- hasDocgen(component)", (0, import_docs_tools.hasDocgen)(component));
  if (!(0, import_docs_tools.hasDocgen)(component)) {
    return null;
  }
  const argTypes2 = {};
  ARG_TYPE_SECTIONS.forEach((section) => {
    const props = (0, import_docs_tools.extractComponentProps)(component, section);
    console.log("########     --- props", props);
    props.forEach(({ docgenInfo, propDef }) => {
      const {
        name,
        description,
        type,
        default: defaultSummary,
        required,
        tags = [],
        global
      } = docgenInfo;
      console.log("docgenInfo", docgenInfo);
      if (argTypes2[name] || global) {
        return;
      }
      const sbType = section === "props" ? convert(docgenInfo) : { name: type == null ? void 0 : type.toString() };
      const definedTypes = `${(type ? type.name || type.toString() : " ").replace(
        " | undefined",
        ""
      )}`;
      const descriptions = `${tags.length ? `${tags.map((tag) => `@${tag.name}: ${tag.text}`).join("<br>")}<br><br>` : ""}${description}`;
      argTypes2[name] = {
        name,
        description: descriptions.replace("undefined", ""),
        defaultValue: { summary: defaultSummary },
        type: { required, ...sbType },
        table: {
          type: { summary: definedTypes },
          jsDocTags: tags,
          defaultValue: { summary: defaultSummary },
          category: section
        },
        control: { disable: !["props", "slots"].includes(section) }
      };
    });
  });
  return argTypes2;
};
var convert = ({ schema: schemaType }) => {
  if (typeof schemaType === "object" && schemaType.kind === "enum" && Array.isArray(schemaType.schema)) {
    const values = schemaType.schema.filter(
      (item) => item !== "undefined" && (item !== null && typeof item === "object" && item.kind !== "array" || typeof item === "string")
    ).map((item) => typeof item !== "string" ? item.schema.toString() : item).map((item) => item.replace(/'/g, '"')) || [];
    const isSingle = values.length === 1;
    const isBoolean = values.length === 2 && values.every((item) => item === "true" || item === "false");
    const isLateralUnion = values.length > 1 && values.every((item) => item.startsWith('"') && item.endsWith('"'));
    const isEnum = values.length > 1 && values.every(
      (item) => !item.startsWith('"') && typeof item === "string" && item.includes(".")
    );
    const sbType = { name: "enum", value: values.map((item) => item.replace(/"/g, "")) };
    if (isSingle)
      return { name: values[0] };
    if (isBoolean)
      return { ...sbType, name: "boolean" };
    if (isLateralUnion || isEnum)
      return { ...sbType, name: "enum" };
    return {
      name: values.length ? values[0] : "array"
    };
  }
  if (typeof schemaType === "object" && schemaType.kind === "object" && typeof schemaType.schema === "object") {
    const schemaObject = schemaType.schema;
    const props = Object.fromEntries(
      Object.entries(schemaObject).map(([key, value]) => {
        return [key, value];
      })
    );
    return {
      name: "object",
      value: props
    };
  }
  return { name: schemaType };
};

// src/docs/sourceDecorator.ts
var import_preview_api = require("@storybook/preview-api");
var import_docs_tools2 = require("@storybook/docs-tools");
var import_compiler_core = require("@vue/compiler-core");
var import_vue = require("vue");
var import_lodash = require("lodash");

// src/docs/utils.ts
var omitEvent = (args2) => args2 ? Object.fromEntries(Object.entries(args2).filter(([key, value]) => !key.startsWith("on"))) : {};
var displayObject = (obj) => {
  if (obj && typeof obj === "object") {
    return `{${Object.keys(obj).map((key) => `${key}:${displayObject(obj[key])}`).join(",")}}`;
  }
  if (typeof obj === "string")
    return `'${obj}'`;
  return obj == null ? void 0 : obj.toString();
};
var htmlEventAttributeToVueEventAttribute = (key) => {
  return /^on[A-Za-z]/.test(key) ? key.replace(/^on/, "v-on:").toLowerCase() : key;
};
var directiveSource = (key, value) => key.includes("on") ? `${htmlEventAttributeToVueEventAttribute(key)}='()=>({})'` : `${key}="${value}"`;
var attributeSource = (key, value, dynamic) => (
  // convert html event key to vue event key
  ["boolean", "number", "object"].includes(typeof value) || // dynamic value
  dynamic && ["style", "class"].includes(key) ? `:${key}="${displayObject(value)}"` : directiveSource(key, value)
);
var evalExp = (argExpValue, args2) => {
  let evalVal = argExpValue;
  if (evalVal && /v-bind="(\w+)"/.test(evalVal))
    return evalVal.replace(/"(\w+)"/g, `"${displayObject(args2)}"`);
  Object.keys(args2).forEach((akey) => {
    const regexMatch = new RegExp(`(\\w+)\\.${akey}`, "g");
    const regexTarget = new RegExp(`(\\w+)\\.${akey}`, "g");
    if (regexMatch.test(evalVal)) {
      evalVal = evalVal.replace(regexTarget, displayObject(args2[akey]));
    }
  });
  return evalVal;
};
var replaceValueWithRef = (source2, args2, ref) => {
  const value = ref ? args2[ref] : "args";
  const bindValue = () => {
    const argsRef = Object.fromEntries(Object.entries(args2).map(([key]) => [key, key]));
    return displayObject(argsRef).replace(/'/g, "");
  };
  const regexMatch = new RegExp(`="${value}"`, "g");
  return source2.replace(regexMatch, `="${ref ?? bindValue()}"`);
};
function generateExpression(slot) {
  let body = slot.toString().split("=>")[1].trim().replace("return", "").trim();
  if (body.startsWith("{") && body.endsWith("}")) {
    body = body.substring(1, body.length - 1).trim();
  }
  return `{{${body}}}`;
}

// src/docs/sourceDecorator.ts
var skipSourceRender = (context) => {
  var _a;
  const sourceParams = (_a = context == null ? void 0 : context.parameters.docs) == null ? void 0 : _a.source;
  const isArgsStory = context == null ? void 0 : context.parameters.__isArgsStory;
  const isDocsViewMode = (context == null ? void 0 : context.viewMode) === "docs";
  if ((sourceParams == null ? void 0 : sourceParams.type) === import_docs_tools2.SourceType.DYNAMIC) {
    return false;
  }
  return !isDocsViewMode || !isArgsStory || (sourceParams == null ? void 0 : sourceParams.code) || (sourceParams == null ? void 0 : sourceParams.type) === import_docs_tools2.SourceType.CODE;
};
function generateAttributesSource(tempArgs, args2, argTypes2, byRef2) {
  return Object.keys(tempArgs).map((key) => {
    var _a;
    const source2 = tempArgs[key].loc.source.replace(/\$props/g, "args");
    const argKey = (_a = tempArgs[key].arg) == null ? void 0 : _a.loc.source;
    return byRef2 && argKey ? replaceValueWithRef(source2, args2, argKey) : evalExp(source2, omitEvent(args2));
  }).join(" ");
}
function mapAttributesAndDirectives(props) {
  const tranformKey = (key) => key.startsWith("on") ? key : (0, import_lodash.kebabCase)(key);
  return Object.keys(props).map(
    (key) => ({
      name: "bind",
      type: ["v-", "@", "v-on"].includes(key) ? 7 : 6,
      // 6 is attribute, 7 is directive
      arg: { content: tranformKey(key), loc: { source: tranformKey(key) } },
      // attribute name or directive name (v-bind, v-on, v-model)
      loc: { source: attributeSource(tranformKey(key), props[key]) },
      // attribute value or directive value
      exp: { isStatic: false, loc: { source: props[key] } },
      // directive expression
      modifiers: [""]
    })
  );
}
function mapSlots(slotsArgs, generateComponentSource2, slots) {
  return Object.keys(slotsArgs).map((key) => {
    var _a, _b;
    const slot = slotsArgs[key];
    let slotContent = "";
    const scropedArgs = (_b = (_a = slots.find((s) => s.name === key && s.scoped)) == null ? void 0 : _a.bindings) == null ? void 0 : _b.map((b) => b.name).join(",");
    if (typeof slot === "string") {
      slotContent = slot;
    } else if (typeof slot === "function") {
      slotContent = generateExpression(slot);
    } else if ((0, import_vue.isVNode)(slot)) {
      slotContent = generateComponentSource2(slot);
    } else if (typeof slot === "object" && !(0, import_vue.isVNode)(slot)) {
      slotContent = JSON.stringify(slot);
    }
    const bindingsString = scropedArgs ? `="{${scropedArgs}}"` : "";
    slotContent = slot ? `<template #${key}${bindingsString}>${slotContent}</template>` : ``;
    return {
      type: 2,
      content: slotContent,
      loc: {
        source: slotContent,
        start: { offset: 0, line: 1, column: 0 },
        end: { offset: 0, line: 1, column: 0 }
      }
    };
  });
}
function generateScriptSetup(args2, argTypes2, components) {
  const scriptLines = Object.keys(args2).map(
    (key) => `const ${key} = ${typeof args2[key] === "function" ? `()=>{}` : `ref(${JSON.stringify(args2[key])});`}`
  );
  scriptLines.unshift(`import { ref } from "vue";`);
  return `<script lang='ts' setup>${scriptLines.join("\n")}</script>`;
}
function getTemplateComponents(renderFn, context) {
  try {
    const originalStoryFn = renderFn;
    const storyFn = originalStoryFn ? originalStoryFn(context == null ? void 0 : context.args, context) : context == null ? void 0 : context.component;
    const story = typeof storyFn === "function" ? storyFn() : storyFn;
    const { template } = story;
    if (!template)
      return [(0, import_vue.h)(story, context == null ? void 0 : context.args)];
    return getComponents(template);
  } catch (e) {
    return [];
  }
}
function getComponents(template) {
  const ast = (0, import_compiler_core.baseParse)(template);
  const components = ast == null ? void 0 : ast.children;
  if (!components)
    return [];
  return components;
}
function generateTemplateSource(componentOrNodes, { args, argTypes }, byRef = false) {
  const isElementNode = (node) => node && node.type === 1;
  const isInterpolationNode = (node) => node && node.type === 5;
  const isTextNode = (node) => node && node.type === 2;
  const generateComponentSource = (componentOrNode) => {
    var _a, _b;
    if (isElementNode(componentOrNode)) {
      const { tag: name, props: attributes, children } = componentOrNode;
      const childSources = typeof children === "string" ? children : children.map((child) => generateComponentSource(child)).join("");
      const props = generateAttributesSource(attributes, args, argTypes, byRef);
      return childSources === "" ? `<${name} ${props} />` : `<${name} ${props}>${childSources}</${name}>`;
    }
    if (isTextNode(componentOrNode)) {
      const { content: content2 } = componentOrNode;
      return content2;
    }
    if (isInterpolationNode(componentOrNode)) {
      const { content } = componentOrNode;
      const expValue = evalExp(content.loc.source, args);
      if (expValue === content.loc.source)
        return `{{${expValue}}}`;
      return eval(expValue);
    }
    if ((0, import_vue.isVNode)(componentOrNode)) {
      const vnode = componentOrNode;
      const { props, type, children } = vnode;
      const slotsProps = typeof children === "string" ? void 0 : children;
      const componentSlots = (_a = type == null ? void 0 : type.__docgenInfo) == null ? void 0 : _a.slots;
      const attrsProps = slotsProps ? Object.fromEntries(
        Object.entries(props ?? {}).filter(([key, value]) => !slotsProps[key] && !["class", "style"].includes(key)).map(([key, value]) => [key, value])
      ) : props;
      const attributes = mapAttributesAndDirectives(attrsProps ?? {});
      const slotArgs = Object.fromEntries(
        Object.entries(props ?? {}).filter(([key, value]) => slotsProps == null ? void 0 : slotsProps[key])
      );
      const childSources = children ? typeof children === "string" ? children : mapSlots(slotArgs, generateComponentSource, componentSlots ?? []).map((child) => child.content).join("") : "";
      const name = typeof type === "string" ? type : type.name || type.__name || ((_b = type.__docgenInfo) == null ? void 0 : _b.displayName);
      const propsSource = generateAttributesSource(attributes, args, argTypes, byRef);
      return childSources.trim() === "" ? `<${name} ${propsSource}/>` : `<${name} ${propsSource}>${childSources}</${name}>`;
    }
    return null;
  };
  const componentsOrNodes = Array.isArray(componentOrNodes) ? componentOrNodes : [componentOrNodes];
  const source = componentsOrNodes.map((componentOrNode2) => generateComponentSource(componentOrNode2)).join(" ");
  return source || null;
}
var sourceDecorator = (storyFn, context) => {
  const skip = skipSourceRender(context);
  const story = storyFn();
  (0, import_vue.watch)(
    () => context.args,
    () => {
      if (!skip) {
        generateSource(context);
      }
    },
    { immediate: true, deep: true }
  );
  return story;
};
function generateSource(context) {
  var _a, _b, _c;
  const channel = import_preview_api.addons.getChannel();
  const { args: args2 = {}, argTypes: argTypes2 = {}, id } = context || {};
  const storyComponents = getTemplateComponents(context == null ? void 0 : context.originalStoryFn, context);
  const withScript = ((_c = (_b = (_a = context == null ? void 0 : context.parameters) == null ? void 0 : _a.docs) == null ? void 0 : _b.source) == null ? void 0 : _c.withScriptSetup) || false;
  const generatedScript = withScript ? generateScriptSetup(args2, argTypes2, storyComponents) : "";
  const generatedTemplate = generateTemplateSource(storyComponents, context, withScript);
  if (generatedTemplate) {
    const source2 = `${generatedScript}
 <template>
 ${generatedTemplate} 
</template>`;
    channel.emit(import_docs_tools2.SNIPPET_RENDERED, { id, args: args2, source: source2, format: "vue" });
    return source2;
  }
  return null;
}

// src/docs/config.ts
var parameters = {
  docs: {
    story: { inline: true },
    extractArgTypes,
    extractComponentDescription: import_docs_tools3.extractComponentDescription
  }
};
var decorators = [sourceDecorator];
var argTypesEnhancers = [import_docs_tools3.enhanceArgTypes];

// src/render.ts
var import_vue2 = require("vue");
var render = (props, context) => {
  const { id, component: Component } = context;
  if (!Component) {
    throw new Error(
      `Unable to render story ${id} as the component annotation is missing from the default export`
    );
  }
  return () => (0, import_vue2.h)(Component, props, getSlots(props, context));
};
var runSetupFunctions = async (app, storyContext) => {
  if (globalThis && globalThis.PLUGINS_SETUP_FUNCTIONS)
    await Promise.all([...globalThis.PLUGINS_SETUP_FUNCTIONS].map((fn) => fn(app, storyContext)));
};
var map = /* @__PURE__ */ new Map();
async function renderToCanvas({ storyFn, forceRemount, showMain, showException, storyContext, id }, canvasElement) {
  const existingApp = map.get(canvasElement);
  if (existingApp && !forceRemount) {
    const element = storyFn();
    const args2 = getArgs(element, storyContext);
    updateArgs(existingApp.reactiveArgs, args2);
    return () => {
      teardown(existingApp.vueApp, canvasElement);
    };
  }
  if (existingApp && forceRemount)
    teardown(existingApp.vueApp, canvasElement);
  const vueApp = (0, import_vue2.createApp)({
    setup() {
      storyContext.args = (0, import_vue2.reactive)(storyContext.args);
      const rootElement = storyFn();
      const args2 = getArgs(rootElement, storyContext);
      const appState = {
        vueApp,
        reactiveArgs: (0, import_vue2.reactive)(args2)
      };
      map.set(canvasElement, appState);
      return () => {
        return (0, import_vue2.h)(rootElement);
      };
    }
  });
  vueApp.config.errorHandler = (e) => showException(e);
  await runSetupFunctions(vueApp, storyContext);
  vueApp.mount(canvasElement);
  showMain();
  return () => {
    teardown(vueApp, canvasElement);
  };
}
function getSlots(props, context) {
  const { argTypes: argTypes2 } = context;
  const slots = Object.entries(props).filter(([key]) => {
    var _a, _b;
    return ((_b = (_a = argTypes2[key]) == null ? void 0 : _a.table) == null ? void 0 : _b.category) === "slots";
  }).map(([key, value]) => [key, typeof value === "function" ? value : () => value]);
  return Object.fromEntries(slots);
}
function getArgs(element, storyContext) {
  return (element && (0, import_vue2.isVNode)(element) ? element.props : storyContext.args) ?? {};
}
function updateArgs(reactiveArgs, nextArgs) {
  if (Object.keys(nextArgs).length === 0)
    return;
  const currentArgs = (0, import_vue2.isReactive)(reactiveArgs) ? reactiveArgs : (0, import_vue2.reactive)(reactiveArgs);
  Object.keys(currentArgs).forEach((key) => {
    if (!(key in nextArgs)) {
      delete currentArgs[key];
    }
  });
  Object.assign(currentArgs, nextArgs);
}
function teardown(storybookApp, canvasElement) {
  storybookApp == null ? void 0 : storybookApp.unmount();
  if (map.has(canvasElement))
    map.delete(canvasElement);
}

// src/decorateStory.ts
var import_vue3 = require("vue");
var import_preview_api2 = require("@storybook/preview-api");
function normalizeFunctionalComponent(options) {
  return typeof options === "function" ? { render: options, name: options.name } : options;
}
function prepare(rawStory, innerStory) {
  const story = rawStory;
  if (story === null) {
    return null;
  }
  if (typeof story === "function")
    return story;
  if (innerStory) {
    return {
      // Normalize so we can always spread an object
      ...normalizeFunctionalComponent(story),
      components: { ...story.components || {}, story: innerStory }
    };
  }
  return {
    render() {
      return (0, import_vue3.h)(story);
    }
  };
}
function decorateStory(storyFn, decorators2) {
  return decorators2.reduce(
    (decorated, decorator) => (context) => {
      let story;
      const decoratedStory = decorator((update) => {
        const sanitizedUpdate = (0, import_preview_api2.sanitizeStoryContextUpdate)(update);
        if (update)
          sanitizedUpdate.args = Object.assign(context.args, sanitizedUpdate.args);
        story = decorated({ ...context, ...sanitizedUpdate });
        return story;
      }, context);
      if (!story)
        story = decorated(context);
      if (decoratedStory === story) {
        return story;
      }
      const innerStory = () => (0, import_vue3.h)(story);
      return prepare(decoratedStory, innerStory);
    },
    (context) => prepare(storyFn(context))
  );
}

// src/config.ts
var parameters2 = { renderer: "vue3", ...parameters };
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  applyDecorators,
  argTypesEnhancers,
  decorators,
  parameters,
  render,
  renderToCanvas
});
