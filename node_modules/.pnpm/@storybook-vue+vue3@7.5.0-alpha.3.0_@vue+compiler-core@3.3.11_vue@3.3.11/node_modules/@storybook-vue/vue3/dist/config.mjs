export { decorateStory as applyDecorators, render, renderToCanvas } from './chunk-WK43OID3.mjs';
import { enhanceArgTypes, SNIPPET_RENDERED, extractComponentDescription, hasDocgen, extractComponentProps, SourceType } from '@storybook/docs-tools';
import { addons } from '@storybook/preview-api';
import { baseParse } from '@vue/compiler-core';
import { watch, h, isVNode } from 'vue';
import { kebabCase } from 'lodash';

var ARG_TYPE_SECTIONS = ["props", "events", "slots", "exposed"];
var extractArgTypes = (component) => {
  console.log("########     --- component", component);
  console.log("########     --- hasDocgen(component)", hasDocgen(component));
  if (!hasDocgen(component)) {
    return null;
  }
  const argTypes2 = {};
  ARG_TYPE_SECTIONS.forEach((section) => {
    const props = extractComponentProps(component, section);
    console.log("########     --- props", props);
    props.forEach(({ docgenInfo, propDef }) => {
      const {
        name,
        description,
        type,
        default: defaultSummary,
        required,
        tags = [],
        global
      } = docgenInfo;
      console.log("docgenInfo", docgenInfo);
      if (argTypes2[name] || global) {
        return;
      }
      const sbType = section === "props" ? convert(docgenInfo) : { name: type?.toString() };
      const definedTypes = `${(type ? type.name || type.toString() : " ").replace(
        " | undefined",
        ""
      )}`;
      const descriptions = `${tags.length ? `${tags.map((tag) => `@${tag.name}: ${tag.text}`).join("<br>")}<br><br>` : ""}${description}`;
      argTypes2[name] = {
        name,
        description: descriptions.replace("undefined", ""),
        defaultValue: { summary: defaultSummary },
        type: { required, ...sbType },
        table: {
          type: { summary: definedTypes },
          jsDocTags: tags,
          defaultValue: { summary: defaultSummary },
          category: section
        },
        control: { disable: !["props", "slots"].includes(section) }
      };
    });
  });
  return argTypes2;
};
var convert = ({ schema: schemaType }) => {
  if (typeof schemaType === "object" && schemaType.kind === "enum" && Array.isArray(schemaType.schema)) {
    const values = schemaType.schema.filter(
      (item) => item !== "undefined" && (item !== null && typeof item === "object" && item.kind !== "array" || typeof item === "string")
    ).map((item) => typeof item !== "string" ? item.schema.toString() : item).map((item) => item.replace(/'/g, '"')) || [];
    const isSingle = values.length === 1;
    const isBoolean = values.length === 2 && values.every((item) => item === "true" || item === "false");
    const isLateralUnion = values.length > 1 && values.every((item) => item.startsWith('"') && item.endsWith('"'));
    const isEnum = values.length > 1 && values.every(
      (item) => !item.startsWith('"') && typeof item === "string" && item.includes(".")
    );
    const sbType = { name: "enum", value: values.map((item) => item.replace(/"/g, "")) };
    if (isSingle)
      return { name: values[0] };
    if (isBoolean)
      return { ...sbType, name: "boolean" };
    if (isLateralUnion || isEnum)
      return { ...sbType, name: "enum" };
    return {
      name: values.length ? values[0] : "array"
    };
  }
  if (typeof schemaType === "object" && schemaType.kind === "object" && typeof schemaType.schema === "object") {
    const schemaObject = schemaType.schema;
    const props = Object.fromEntries(
      Object.entries(schemaObject).map(([key, value]) => {
        return [key, value];
      })
    );
    return {
      name: "object",
      value: props
    };
  }
  return { name: schemaType };
};

// src/docs/utils.ts
var omitEvent = (args2) => args2 ? Object.fromEntries(Object.entries(args2).filter(([key, value]) => !key.startsWith("on"))) : {};
var displayObject = (obj) => {
  if (obj && typeof obj === "object") {
    return `{${Object.keys(obj).map((key) => `${key}:${displayObject(obj[key])}`).join(",")}}`;
  }
  if (typeof obj === "string")
    return `'${obj}'`;
  return obj?.toString();
};
var htmlEventAttributeToVueEventAttribute = (key) => {
  return /^on[A-Za-z]/.test(key) ? key.replace(/^on/, "v-on:").toLowerCase() : key;
};
var directiveSource = (key, value) => key.includes("on") ? `${htmlEventAttributeToVueEventAttribute(key)}='()=>({})'` : `${key}="${value}"`;
var attributeSource = (key, value, dynamic) => (
  // convert html event key to vue event key
  ["boolean", "number", "object"].includes(typeof value) || // dynamic value
  dynamic && ["style", "class"].includes(key) ? `:${key}="${displayObject(value)}"` : directiveSource(key, value)
);
var evalExp = (argExpValue, args2) => {
  let evalVal = argExpValue;
  if (evalVal && /v-bind="(\w+)"/.test(evalVal))
    return evalVal.replace(/"(\w+)"/g, `"${displayObject(args2)}"`);
  Object.keys(args2).forEach((akey) => {
    const regexMatch = new RegExp(`(\\w+)\\.${akey}`, "g");
    const regexTarget = new RegExp(`(\\w+)\\.${akey}`, "g");
    if (regexMatch.test(evalVal)) {
      evalVal = evalVal.replace(regexTarget, displayObject(args2[akey]));
    }
  });
  return evalVal;
};
var replaceValueWithRef = (source2, args2, ref) => {
  const value = ref ? args2[ref] : "args";
  const bindValue = () => {
    const argsRef = Object.fromEntries(Object.entries(args2).map(([key]) => [key, key]));
    return displayObject(argsRef).replace(/'/g, "");
  };
  const regexMatch = new RegExp(`="${value}"`, "g");
  return source2.replace(regexMatch, `="${ref ?? bindValue()}"`);
};
function generateExpression(slot) {
  let body = slot.toString().split("=>")[1].trim().replace("return", "").trim();
  if (body.startsWith("{") && body.endsWith("}")) {
    body = body.substring(1, body.length - 1).trim();
  }
  return `{{${body}}}`;
}

// src/docs/sourceDecorator.ts
var skipSourceRender = (context) => {
  const sourceParams = context?.parameters.docs?.source;
  const isArgsStory = context?.parameters.__isArgsStory;
  const isDocsViewMode = context?.viewMode === "docs";
  if (sourceParams?.type === SourceType.DYNAMIC) {
    return false;
  }
  return !isDocsViewMode || !isArgsStory || sourceParams?.code || sourceParams?.type === SourceType.CODE;
};
function generateAttributesSource(tempArgs, args2, argTypes2, byRef2) {
  return Object.keys(tempArgs).map((key) => {
    const source2 = tempArgs[key].loc.source.replace(/\$props/g, "args");
    const argKey = tempArgs[key].arg?.loc.source;
    return byRef2 && argKey ? replaceValueWithRef(source2, args2, argKey) : evalExp(source2, omitEvent(args2));
  }).join(" ");
}
function mapAttributesAndDirectives(props) {
  const tranformKey = (key) => key.startsWith("on") ? key : kebabCase(key);
  return Object.keys(props).map(
    (key) => ({
      name: "bind",
      type: ["v-", "@", "v-on"].includes(key) ? 7 : 6,
      // 6 is attribute, 7 is directive
      arg: { content: tranformKey(key), loc: { source: tranformKey(key) } },
      // attribute name or directive name (v-bind, v-on, v-model)
      loc: { source: attributeSource(tranformKey(key), props[key]) },
      // attribute value or directive value
      exp: { isStatic: false, loc: { source: props[key] } },
      // directive expression
      modifiers: [""]
    })
  );
}
function mapSlots(slotsArgs, generateComponentSource2, slots) {
  return Object.keys(slotsArgs).map((key) => {
    const slot = slotsArgs[key];
    let slotContent = "";
    const scropedArgs = slots.find((s) => s.name === key && s.scoped)?.bindings?.map((b) => b.name).join(",");
    if (typeof slot === "string") {
      slotContent = slot;
    } else if (typeof slot === "function") {
      slotContent = generateExpression(slot);
    } else if (isVNode(slot)) {
      slotContent = generateComponentSource2(slot);
    } else if (typeof slot === "object" && !isVNode(slot)) {
      slotContent = JSON.stringify(slot);
    }
    const bindingsString = scropedArgs ? `="{${scropedArgs}}"` : "";
    slotContent = slot ? `<template #${key}${bindingsString}>${slotContent}</template>` : ``;
    return {
      type: 2,
      content: slotContent,
      loc: {
        source: slotContent,
        start: { offset: 0, line: 1, column: 0 },
        end: { offset: 0, line: 1, column: 0 }
      }
    };
  });
}
function generateScriptSetup(args2, argTypes2, components) {
  const scriptLines = Object.keys(args2).map(
    (key) => `const ${key} = ${typeof args2[key] === "function" ? `()=>{}` : `ref(${JSON.stringify(args2[key])});`}`
  );
  scriptLines.unshift(`import { ref } from "vue";`);
  return `<script lang='ts' setup>${scriptLines.join("\n")}<\/script>`;
}
function getTemplateComponents(renderFn, context) {
  try {
    const originalStoryFn = renderFn;
    const storyFn = originalStoryFn ? originalStoryFn(context?.args, context) : context?.component;
    const story = typeof storyFn === "function" ? storyFn() : storyFn;
    const { template } = story;
    if (!template)
      return [h(story, context?.args)];
    return getComponents(template);
  } catch (e) {
    return [];
  }
}
function getComponents(template) {
  const ast = baseParse(template);
  const components = ast?.children;
  if (!components)
    return [];
  return components;
}
function generateTemplateSource(componentOrNodes, { args, argTypes }, byRef = false) {
  const isElementNode = (node) => node && node.type === 1;
  const isInterpolationNode = (node) => node && node.type === 5;
  const isTextNode = (node) => node && node.type === 2;
  const generateComponentSource = (componentOrNode) => {
    if (isElementNode(componentOrNode)) {
      const { tag: name, props: attributes, children } = componentOrNode;
      const childSources = typeof children === "string" ? children : children.map((child) => generateComponentSource(child)).join("");
      const props = generateAttributesSource(attributes, args, argTypes, byRef);
      return childSources === "" ? `<${name} ${props} />` : `<${name} ${props}>${childSources}</${name}>`;
    }
    if (isTextNode(componentOrNode)) {
      const { content: content2 } = componentOrNode;
      return content2;
    }
    if (isInterpolationNode(componentOrNode)) {
      const { content } = componentOrNode;
      const expValue = evalExp(content.loc.source, args);
      if (expValue === content.loc.source)
        return `{{${expValue}}}`;
      return eval(expValue);
    }
    if (isVNode(componentOrNode)) {
      const vnode = componentOrNode;
      const { props, type, children } = vnode;
      const slotsProps = typeof children === "string" ? void 0 : children;
      const componentSlots = type?.__docgenInfo?.slots;
      const attrsProps = slotsProps ? Object.fromEntries(
        Object.entries(props ?? {}).filter(([key, value]) => !slotsProps[key] && !["class", "style"].includes(key)).map(([key, value]) => [key, value])
      ) : props;
      const attributes = mapAttributesAndDirectives(attrsProps ?? {});
      const slotArgs = Object.fromEntries(
        Object.entries(props ?? {}).filter(([key, value]) => slotsProps?.[key])
      );
      const childSources = children ? typeof children === "string" ? children : mapSlots(slotArgs, generateComponentSource, componentSlots ?? []).map((child) => child.content).join("") : "";
      const name = typeof type === "string" ? type : type.name || type.__name || type.__docgenInfo?.displayName;
      const propsSource = generateAttributesSource(attributes, args, argTypes, byRef);
      return childSources.trim() === "" ? `<${name} ${propsSource}/>` : `<${name} ${propsSource}>${childSources}</${name}>`;
    }
    return null;
  };
  const componentsOrNodes = Array.isArray(componentOrNodes) ? componentOrNodes : [componentOrNodes];
  const source = componentsOrNodes.map((componentOrNode2) => generateComponentSource(componentOrNode2)).join(" ");
  return source || null;
}
var sourceDecorator = (storyFn, context) => {
  const skip = skipSourceRender(context);
  const story = storyFn();
  watch(
    () => context.args,
    () => {
      if (!skip) {
        generateSource(context);
      }
    },
    { immediate: true, deep: true }
  );
  return story;
};
function generateSource(context) {
  const channel = addons.getChannel();
  const { args: args2 = {}, argTypes: argTypes2 = {}, id } = context || {};
  const storyComponents = getTemplateComponents(context?.originalStoryFn, context);
  const withScript = context?.parameters?.docs?.source?.withScriptSetup || false;
  const generatedScript = withScript ? generateScriptSetup(args2) : "";
  const generatedTemplate = generateTemplateSource(storyComponents, context, withScript);
  if (generatedTemplate) {
    const source2 = `${generatedScript}
 <template>
 ${generatedTemplate} 
</template>`;
    channel.emit(SNIPPET_RENDERED, { id, args: args2, source: source2, format: "vue" });
    return source2;
  }
  return null;
}

// src/docs/config.ts
var parameters = {
  docs: {
    story: { inline: true },
    extractArgTypes,
    extractComponentDescription
  }
};
var decorators = [sourceDecorator];
var argTypesEnhancers = [enhanceArgTypes];

// src/config.ts
var parameters2 = { renderer: "vue3", ...parameters };

export { argTypesEnhancers, decorators, parameters2 as parameters };
