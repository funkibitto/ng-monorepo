import { h, createApp, reactive, isVNode, isReactive } from 'vue';
import { sanitizeStoryContextUpdate } from '@storybook/preview-api';

// src/decorateStory.ts
function normalizeFunctionalComponent(options) {
  return typeof options === "function" ? { render: options, name: options.name } : options;
}
function prepare(rawStory, innerStory) {
  const story = rawStory;
  if (story === null) {
    return null;
  }
  if (typeof story === "function")
    return story;
  if (innerStory) {
    return {
      // Normalize so we can always spread an object
      ...normalizeFunctionalComponent(story),
      components: { ...story.components || {}, story: innerStory }
    };
  }
  return {
    render() {
      return h(story);
    }
  };
}
function decorateStory(storyFn, decorators) {
  return decorators.reduce(
    (decorated, decorator) => (context) => {
      let story;
      const decoratedStory = decorator((update) => {
        const sanitizedUpdate = sanitizeStoryContextUpdate(update);
        if (update)
          sanitizedUpdate.args = Object.assign(context.args, sanitizedUpdate.args);
        story = decorated({ ...context, ...sanitizedUpdate });
        return story;
      }, context);
      if (!story)
        story = decorated(context);
      if (decoratedStory === story) {
        return story;
      }
      const innerStory = () => h(story);
      return prepare(decoratedStory, innerStory);
    },
    (context) => prepare(storyFn(context))
  );
}
var render = (props, context) => {
  const { id, component: Component } = context;
  if (!Component) {
    throw new Error(
      `Unable to render story ${id} as the component annotation is missing from the default export`
    );
  }
  return () => h(Component, props, getSlots(props, context));
};
var setup = (fn) => {
  globalThis.PLUGINS_SETUP_FUNCTIONS ??= /* @__PURE__ */ new Set();
  globalThis.PLUGINS_SETUP_FUNCTIONS.add(fn);
};
var runSetupFunctions = async (app, storyContext) => {
  if (globalThis && globalThis.PLUGINS_SETUP_FUNCTIONS)
    await Promise.all([...globalThis.PLUGINS_SETUP_FUNCTIONS].map((fn) => fn(app, storyContext)));
};
var map = /* @__PURE__ */ new Map();
async function renderToCanvas({ storyFn, forceRemount, showMain, showException, storyContext, id }, canvasElement) {
  const existingApp = map.get(canvasElement);
  if (existingApp && !forceRemount) {
    const element = storyFn();
    const args = getArgs(element, storyContext);
    updateArgs(existingApp.reactiveArgs, args);
    return () => {
      teardown(existingApp.vueApp, canvasElement);
    };
  }
  if (existingApp && forceRemount)
    teardown(existingApp.vueApp, canvasElement);
  const vueApp = createApp({
    setup() {
      storyContext.args = reactive(storyContext.args);
      const rootElement = storyFn();
      const args = getArgs(rootElement, storyContext);
      const appState = {
        vueApp,
        reactiveArgs: reactive(args)
      };
      map.set(canvasElement, appState);
      return () => {
        return h(rootElement);
      };
    }
  });
  vueApp.config.errorHandler = (e) => showException(e);
  await runSetupFunctions(vueApp, storyContext);
  vueApp.mount(canvasElement);
  showMain();
  return () => {
    teardown(vueApp, canvasElement);
  };
}
function getSlots(props, context) {
  const { argTypes } = context;
  const slots = Object.entries(props).filter(([key]) => argTypes[key]?.table?.category === "slots").map(([key, value]) => [key, typeof value === "function" ? value : () => value]);
  return Object.fromEntries(slots);
}
function getArgs(element, storyContext) {
  return (element && isVNode(element) ? element.props : storyContext.args) ?? {};
}
function updateArgs(reactiveArgs, nextArgs) {
  if (Object.keys(nextArgs).length === 0)
    return;
  const currentArgs = isReactive(reactiveArgs) ? reactiveArgs : reactive(reactiveArgs);
  Object.keys(currentArgs).forEach((key) => {
    if (!(key in nextArgs)) {
      delete currentArgs[key];
    }
  });
  Object.assign(currentArgs, nextArgs);
}
function teardown(storybookApp, canvasElement) {
  storybookApp?.unmount();
  if (map.has(canvasElement))
    map.delete(canvasElement);
}

export { decorateStory, render, renderToCanvas, setup };
